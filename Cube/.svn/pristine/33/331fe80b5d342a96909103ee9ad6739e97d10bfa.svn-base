
#include "Player.h"
#include <vector>


/*  Copyright notice / uses
 
   1. SFML API :
Original website: http://www.sfml-dev.org
License: https://opensource.org/licenses/Zlib

  2. Rabbit Sprite Sheets :
Credits: Art by Stephen "Redshrike" Challener and the OpenSurge Team ( http://opensnc.sourceforge.net). 
Commissioned by OpenGameArt.org (http://opengameart.org)
Original work possible to download: http://opengameart.org/content/surge-of-opensurge-for-ultimate-smash-friends
License: http://creativecommons.org/licenses/by/3.0/,
http://static.opengameart.org/OGA-BY-3.0.txt
Changes: An orange rabbit Sprite Sheet's background was changed to the color of grey one. 
Some animation frames were moved by specific offsets to remove frame overlapping.

  3. "Blazed" font :
Credits: author: Bright Ideas
Downloaded from: http://all-free-download.com/font/download/blazed_font_2082.html


4. Filth Texture set
By Georges "TRaK" Grondin
drognin@gmail.com
http://trak.mercenariesguild.net/

License: http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
Original work possible to download: http://opengameart.org/node/7230

5. Ladder
Credits: Marta Nowaczyk
Original work possible to download: http://opengameart.org/content/2d-platform-accessories
License: http://creativecommons.org/licenses/by/3.0/
Changes: Copied and pasted so ladder is twice as high.
-----------------------------------------------------------------------
Public Domain:
  6. Fire trap particles
  7. Roman column
*/

//font charset name
const std::string name_font_blazed = "Blazed.ttf";
//sprite sheet texture names
 const std::string name_image_lis = "texture.png";
 const std::string name_image_lis2 = "texture2.png";
 const std::string name_image_fire = "fire.png";
 const std::string name_image_red_floor = "trak_tile_red.jpg";
 const std::string name_image_grey_floor = "trak_tile_g.jpg";
 const std::string name_image_yellow_floor = "trak_tile_y.jpg";
 const std::string name_image_exit_border = "trak_panelsmall_5.jpg";
 const std::string name_image_exit_middle = "trak_panelsmall_2.jpg";
 const std::string name_image_ladder = "ladder.png";
 const std::string name_image_column = "Column.png";

int main()
{


	// make every other game different
	srand(time(NULL));
	//initialize data
	// new variables for animated objects data
	Sprite_Sheet_Data lis;
	Sprite_Sheet_Data lis2;
	
	Sprite_Sheet_Data fire;
	Sprite_Sheet_Data background_r;
	Sprite_Sheet_Data background_y;
	Sprite_Sheet_Data background_g;
	Sprite_Sheet_Data exitborder;
	Sprite_Sheet_Data exitmiddle;
	Sprite_Sheet_Data ladder;

	Sprite_Sheet_Data column;


	//0-1 player skins
	//2-4 background
	// 5 - 7 exits (border,middle, ladder)
	// 8 column
	// 9 - 11 room features ( step, projectile, enemy)
	Sprite_Sheet_Data **graphics = new Sprite_Sheet_Data*[12];
	graphics[0] = &lis;
	graphics[1] = &lis2;
	graphics[2] = &background_r;
	graphics[3] = &background_y;
	graphics[4] = &background_g;
	graphics[5] = &exitborder;
	graphics[6] = &exitmiddle;
	graphics[7] = &ladder;
	graphics[8] = &column;
	graphics[9] = &fire;
	graphics[10] = NULL;
	graphics[11] = NULL;
	// initializing particular sheets data
    //lis
	//set it to number of frames before creating effective frames array for type of animation 
	//and just copy 'block of effective frames initialization'
	int effective_frames_help = 0;
	// sprite sheet width
	lis.size = 1096; 
	
	fire.size = 512;
	background_r.size = 256;
	ladder.size = 128;
	column.size = 256;
	// size of object's body collision
	lis.width = 36; lis.height = 36;

	fire.width = 40; fire.height = 40;
	background_r.width = 256; background_r.height = 256;
	exitborder.width = 64; exitborder.height = 64;
	exitmiddle.width = 64; exitmiddle.height = 64;
	ladder.width = 50; ladder.height = 50;
	column.width = 36; column.height = 50;

	//creating animation data with number of frames, starting pixels, pixel jumps to another frame and size modifier for animation load purpose
	lis.still = Type_of_Animation(1, sf::Vector2i(2, 18), sf::Vector2i(68, 0), sf::Vector2i(18, 40));
	lis.go = Type_of_Animation(6, sf::Vector2i(8, 100), sf::Vector2i(68, 0), sf::Vector2i(18, 40));
	
	effective_frames_help = 6;
	// block of effective frames initialization
	int *lis_attack_effective_frames = new int[effective_frames_help];
	for (int i = 0; i < effective_frames_help;i++)
	{
		lis_attack_effective_frames[i] = 0;
	}
	// then you set your actually effective frames to desired values
	// 0 is no effect
	// 1 is attack that deals 1/5 of damage, interrupts enemy, does not damage blocking enemy
	// 2 deals full damage, knocks enemy back, deals 1 damage when blocked
	// 3 deals 110% damage no matter if enemy blocks, knocks back and up
	lis_attack_effective_frames[1] = 1;
	lis_attack_effective_frames[4] = 2;

	// more animations
	lis.attack = Type_of_Animation(6, sf::Vector2i(0, 448), sf::Vector2i(62, 0), sf::Vector2i(18, 40), lis_attack_effective_frames);
	lis.interrupted = Type_of_Animation(2, sf::Vector2i(280, 18), sf::Vector2i(0, 0), sf::Vector2i(18, 40));
	lis.hit = Type_of_Animation(2, sf::Vector2i(214, 17), sf::Vector2i(0, 0), sf::Vector2i(18, 40));
	lis.block = Type_of_Animation(1, sf::Vector2i(55, 274), sf::Vector2i(0,0), sf::Vector2i(18, 40));


	fire.still = Type_of_Animation(64, sf::Vector2i(0, 0), sf::Vector2i(128,128), sf::Vector2i(88, 88), NULL, 8, sf::Vector2i(0, 12));

	ladder.still = Type_of_Animation(1, sf::Vector2i(0, 0), sf::Vector2i(128, 128), sf::Vector2i(78, 78), NULL,0,sf::Vector2i(-ladder.width/2,-ladder.height/2));

	column.still = Type_of_Animation(1, sf::Vector2i(0, 0), sf::Vector2i(256, 640), sf::Vector2i(220, 590), NULL, 0, sf::Vector2i(-column.width / 2, -column.height / 2 + 100));

	effective_frames_help = 4;
	int *lis_kick_effective_frames = new int[effective_frames_help];
	for (int i = 0; i < effective_frames_help;i++)
	{
		lis_kick_effective_frames[i] = 0;
	}
	lis_kick_effective_frames[3] = 3;
	lis.kick = Type_of_Animation(4, sf::Vector2i(0, 748), sf::Vector2i(72, 0), sf::Vector2i(34, 40), lis_kick_effective_frames);

	effective_frames_help = 30;
	int *lis_use_effective_frames = new int[effective_frames_help];
	for (int i = 0; i < effective_frames_help;i++)
	{
		lis_use_effective_frames[i] = 0;
	}
	lis_use_effective_frames[29] = 1;
	lis.use = Type_of_Animation(30, sf::Vector2i(54, 360), sf::Vector2i(0, 0), sf::Vector2i(44, 40), lis_use_effective_frames);
	// copying data to another skin of the character
	lis2 = lis;
	background_g = background_r;
		background_y = background_r;
	// create and load image for sprite
	sf::Image imlis;
	imlis.loadFromFile(name_image_lis);

	sf::Image imlis2;
	imlis2.loadFromFile(name_image_lis2);
	
	sf::Image imfire;
	imfire.loadFromFile(name_image_fire);

	sf::Image imredfloor;
	imredfloor.loadFromFile(name_image_red_floor);

	sf::Image imgreyfloor;
	imgreyfloor.loadFromFile(name_image_grey_floor);

	sf::Image imyellowfloor;
	imyellowfloor.loadFromFile(name_image_yellow_floor);

	sf::Image imexitborder;
	imexitborder.loadFromFile(name_image_exit_border);

	sf::Image imexitmiddle;
	imexitmiddle.loadFromFile(name_image_exit_middle);


	sf::Image imladder;
	imladder.loadFromFile(name_image_ladder);


	sf::Image imcolumn;
	imcolumn.loadFromFile(name_image_column);
	// mask color of loaded image background
	imlis.createMaskFromColor(sf::Color(0, 128, 128, 255));

	imlis2.createMaskFromColor(sf::Color(0, 128, 128, 255));

	imfire.createMaskFromColor(sf::Color(255, 255, 255, 255));

	imladder.createMaskFromColor(sf::Color(255, 255, 255, 255));

	imcolumn.createMaskFromColor(sf::Color(255, 255, 255, 255));
	// create texture from image
	sf::Texture tex_lis;
	tex_lis.loadFromImage(imlis);

	sf::Texture tex_lis2;
	tex_lis2.loadFromImage(imlis2);

	sf::Texture tex_fire;
	tex_fire.loadFromImage(imfire);

	sf::Texture tex_redfloor;
	tex_redfloor.loadFromImage(imredfloor);

	sf::Texture tex_greyfloor;
	tex_greyfloor.loadFromImage(imgreyfloor);

	sf::Texture tex_yellowfloor;
	tex_yellowfloor.loadFromImage(imyellowfloor);

	sf::Texture tex_exitborder;
	tex_exitborder.loadFromImage(imexitborder);

	sf::Texture tex_exitmiddle;
	tex_exitmiddle.loadFromImage(imexitmiddle);

	sf::Texture tex_ladder;
	tex_ladder.loadFromImage(imladder);

	sf::Texture tex_column;
	tex_column.loadFromImage(imcolumn);
	// create sprite from texture with starting pixels of picture that should be shown at first and its width and height of view (not necessary for animated)
	sf::Sprite xslis = sf::Sprite(tex_lis, sf::IntRect(0, 0, lis.width, lis.height));

	sf::Sprite xslis2 = sf::Sprite(tex_lis2, sf::IntRect(0, 0, lis.width, lis.height));

	sf::Sprite xsfire = sf::Sprite(tex_fire, sf::IntRect(0, 0, fire.width, fire.height));

	sf::Sprite xsredfloor = sf::Sprite(tex_redfloor, sf::IntRect(0, 0, 256, 256));

	sf::Sprite xsgreyfloor = sf::Sprite(tex_greyfloor, sf::IntRect(0, 0, 256, 256));

	sf::Sprite xsyellowfloor = sf::Sprite(tex_yellowfloor, sf::IntRect(0, 0, 256, 256));

	sf::Sprite xsexitborder = sf::Sprite(tex_exitborder, sf::IntRect(0, 0, 64, 64));

	sf::Sprite xsexitmiddle = sf::Sprite(tex_exitmiddle, sf::IntRect(0, 0, 64, 64));

	sf::Sprite xsladder = sf::Sprite(tex_ladder, sf::IntRect(0, 0, 128, 128));

	sf::Sprite xscolumn = sf::Sprite(tex_column, sf::IntRect(0, 0, 256, 640));
	// set scales
	xsfire.setScale(0.5, 0.5);

	xsladder.setScale(0.4, 0.5);

	xscolumn.setScale(0.25, 0.25);
	// send a refence of sprite to data
	lis.data = &xslis;

	lis2.data = &xslis2;
	
	fire.data = &xsfire;
	background_r.data = &xsredfloor;
	background_y.data = &xsyellowfloor;
	background_g.data = &xsgreyfloor;
	exitborder.data = &xsexitborder;
	exitmiddle.data = &xsexitmiddle;

	ladder.data = &xsladder;

	column.data = &xscolumn;
	

	//

	// create the world with its size, borders, max objects that is able to contain
	// it will keep a dynamic array of pointers to objects
	// it is also your window (derivates from RenderWindow)
	World<Physical> *mapa = new World<Physical>(sf::Vector2i(800,600), sf::Vector2i(40,30), 60);

	
	// create terrain

	/*
	Visible backgroundv(mapa->Get_objects(), background_r, sf::Vector2f(0, 0));
	Exit exitbordertop(mapa->Get_objects(), exitborder, sf::Vector2f(mapa->getSize().x / 2, exitborder.height/2),mapa,north);
	Exit exitborderbot(mapa->Get_objects(), exitborder, sf::Vector2f(mapa->getSize().x / 2, mapa->getSize().y- exitborder.height / 2),mapa, south);
	Exit exitborderleft(mapa->Get_objects(), exitborder, sf::Vector2f(exitborder.width/2, mapa->getSize().y / 2),mapa, east);
	Exit exitborderright(mapa->Get_objects(), exitborder, sf::Vector2f(mapa->getSize().x - exitborder.width / 2, mapa->getSize().y / 2),mapa, west);
	Exit exitmiddlev(mapa->Get_objects(), exitmiddle, sf::Vector2f(mapa->getSize().x / 2, mapa->getSize().y/2),mapa,downstairs);
	Exit ladder_obj(mapa->Get_objects(), ladder, sf::Vector2f(0, 0), mapa, upstairs, 3);
	Column column_obj(mapa->Get_objects(), column, sf::Vector2f(0, 0), mapa, 0, sf::Vector3<char>(2,2,2), sum_lower);
	column_obj.setPosition(sf::Vector2f(mapa->getSize().x*(0.5 + 0.05) + (column_obj.Get_width() + column_obj.get_sprite_sheet_animation(column_obj.get_animated_state()).Get_type_of_animation_size_modifier().y * column_obj.getScale().x) / 2 + exitmiddlev.Get_width() / 2, mapa->getSize().y / 2 - column_obj.Get_height() + exitmiddlev.Get_height() / 2));

	Damage_Trap_Spreader d(mapa->Get_objects(), 30, fire, mapa);
	*/
	// create units from data loaded and pass world (to all physical objects too)
	Unit b(mapa->Get_objects(), lis, sf::Vector2f(mapa->Get_border_size().x/2+200, mapa->Get_border_size().y/2 + 200), mapa,  9.f);
	//Unit a(mapa->Get_objects(), lis2, sf::Vector2f(mapa->Get_border_size().x/2 + 60, mapa->Get_border_size().y/2 + 60), mapa,  9.f);
	
	// make units become players and define controls
	//Player x(a, mapa, sf::Keyboard::Left, sf::Keyboard::Right, sf::Keyboard::Up, sf::Keyboard::Down, sf::Keyboard::Numpad0, sf::Keyboard::Add, sf::Keyboard::Numpad9, sf::Keyboard::Numpad4);
	Player y(b, mapa, sf::Keyboard::A, sf::Keyboard::D, sf::Keyboard::W, sf::Keyboard::S, sf::Keyboard::LControl, sf::Keyboard::Tab, sf::Keyboard::Tilde, sf::Keyboard::E);
	

	// create cube that controls all rooms in the game (after creating player)
	Cube<Room> *cube = new Cube<Room>(15, 3, 1, 7, graphics, mapa);


	//creating a collection of players and adding all players to it
	//makes it easier to check events
	std::vector<Object*> players;
	//players.push_back(&x);
	players.push_back(&y);
	//
	// used to order updating objects
	//bool alfa = 0;
	//
	// creating window 
	
	
	//putting game window in the top left hand corner
	mapa->setPosition(sf::Vector2i(0,0));
	
	//game speed in frames per second
	mapa->setFramerateLimit(20);
	//
	while (mapa->isOpen())
	{
		
		// your event loop to trigger actions
		sf::Event event;
		while (mapa->pollEvent(event))
		{
			
			if (event.type == sf::Event::Closed)
			{
				//delete all effective_frames data
				delete[] lis_attack_effective_frames;
				//delete all graphics data
				delete[]  graphics;
				mapa->close();
			}
			// player event checking
			for each (Player* v in players)
			{
				//pass your event pool into the checks
				v->check_event(event);
			}




			
		}

		//remove stuff from window before drawing new frame
		mapa->clear();
		
		// collision check part 1. kick , 2. attack, 3. other guy collision, 4. kickin & attaking guy collision
		// 5. other guy center, 6. attaking guy center
		/*
		sf::RectangleShape vc(sf::Vector2f(36/4+70/5, 36/4+76/8));
		//vc.setOrigin(18,18);
		vc.setPosition(y.getPosition().x + 36 / 4 , y.getPosition().y - 18 - 76 / 8);
	    mapa->draw(vc);
		
		sf::RectangleShape qc(sf::Vector2f( 54 / 5, 76 / 6));
		//qc.setOrigin(18, 18);
		qc.setPosition(y.getPosition().x + 36 / 2, y.getPosition().y );
		mapa->draw(qc);


		sf::RectangleShape gc(sf::Vector2f(36, 36));
		gc.setOrigin(18, 18);
		gc.setPosition(sf::Vector2f(x.getPosition().x, x.getPosition().y));
		mapa->draw(gc);

		sf::RectangleShape bc(sf::Vector2f(36, 36));
		bc.setOrigin(18, 18);
		bc.setPosition(sf::Vector2f(y.getPosition().x,y.getPosition().y));
		mapa->draw(bc);
		sf::CircleShape af(6, 30);
		af.setFillColor(sf::Color(100, 40, 150, 255));
		af.setPosition(x.getPosition());
		mapa->draw(af);
		//
		sf::CircleShape v(2, 10);
		v.setPosition(y.getPosition().x, y.getPosition().y);
		v.setOutlineColor(sf::Color::Cyan);
		v.setFillColor(sf::Color::Cyan);
		mapa->draw(v);
		*/

		
		// draw background
	/*
		for (int i = 0; i < mapa->getSize().y; i += 256)
		{
			for (int j = 0; j < mapa->getSize().x;j += 256)
			{
				backgroundv.setPosition(sf::Vector2f(j, i));
				backgroundv.update(mapa);
			}
		}
		
		exitbordertop.update(mapa);
		exitborderbot.update(mapa);
		exitborderleft.update(mapa);
		exitborderright.update(mapa);
		exitmiddlev.update(mapa);
		ladder_obj.setPosition(sf::Vector2f(mapa->getSize().x*(0.5 - 0.05) -  (ladder_obj.Get_width() + ladder_obj.get_sprite_sheet_animation(ladder_obj.get_animated_state() ).Get_type_of_animation_size_modifier().x )/ 2 - exitmiddlev.Get_width()/2, mapa->getSize().y / 2 - (ladder_obj.Get_height() + ladder_obj.get_sprite_sheet_animation(ladder_obj.get_animated_state()).Get_type_of_animation_size_modifier().y ) /2 ));
		mapa->draw(ladder_obj);
		ladder_obj.setPosition(sf::Vector2f(mapa->getSize().x*(0.5 - 0.05) - (ladder_obj.Get_width() + ladder_obj.get_sprite_sheet_animation(ladder_obj.get_animated_state()).Get_type_of_animation_size_modifier().x) / 2 - exitmiddlev.Get_width()/ 2, mapa->getSize().y / 2));		
		ladder_obj.update(mapa);

		column_obj.update(mapa);
		// update other objects
		d.update(mapa);
		// update moving and higher level objects
		// alfa used to switch between the update order : default and from behind to balance priority
		if (alfa) {
			
			x.update(mapa);
			y.update(mapa);

			alfa = false;
		}
		else
		{
			y.update(mapa);
			x.update(mapa);

			alfa = true;
		} */
		//
		
		// update cube
		cube->update(mapa);
		
		// showing all stuff
		mapa->display();
	}
	
	return 0;
}

